


input GeneratorInput {
  name:String!
  description:String
  graph:String
  editor:String
}

type Generator {
  urn:String
  name:String
  description:String
  createdAt:AWSDateTime
  updatedAt:AWSDateTime
  graph:String
    editor:String
}


input ReleaseFilterInput {
  urn: StringFilterInput
  name: StringFilterInput
  version: StringFilterInput
}

input ReleaseInput {
  name:String!
  vesion: String!
  description:String
}

type Release {
  urn:String!
  name:String!
  version:String!
  description:String
  createdAt:AWSDateTime
  updatedAt:AWSDateTime
    releasedBy: Entity
}




type Query @aws_lambda @aws_cognito_user_pools {
  # Retrieves all invitations in the context of your user
  userInvitations(limit: Int): [Invitation] @aws_lambda @aws_cognito_user_pools
  # queries policies available to the org. The organization is the organization urn
  policies(organization: String!, limit: Int = 40, offset: Int = 0): [Policy]
    @aws_lambda
    @aws_cognito_user_pools
  # Retrieves information about the organizations
  organizations(
    filter: OrganizationFilterInput
    limit: Int = 40
    offset: Int = 0
  ): [Organization] @aws_api_key @aws_lambda @aws_cognito_user_pools
  # Retrieves all projects for an organization. When using the public api key mode you cannot ask for non public resources
  projects(
    organization: String!
    filter: ProjectFilterInput
    limit: Int = 40
    offset: Int = 0
  ): [Project] @aws_api_key @aws_cognito_user_pools @aws_lambda

  # Retrieve a specific project 
  project(   urn: String!  ): Project  @aws_api_key @aws_cognito_user_pools @aws_lambda

  # Retrieves all projects for an organization
  groups(
    organization: String!
    filter: GroupFilterInput
    limit: Int = 40
    offset: Int = 0
  ): [Group] @aws_lambda @aws_cognito_user_pools
  #  Retrieves a specific tokenset
  tokenSet(urn: String!): TokenSet @aws_lambda @aws_cognito_user_pools
  #  Retrieves all accessible tokensets for the current project
  tokenSets(project: String!, limit: Int = 40, offset: Int = 0, filter: TokenSetsFilterInput): [TokenSet!]!
    @aws_lambda
    @aws_cognito_user_pools
  # Retrieves a specific token
  token(urn: String!): RawToken @aws_api_key @aws_cognito_user_pools
  # Retrieves all tokens of the current set
  tokens(
    # The urn of the token set. See the Urn format in the documentation
    set: String!
    # An optional filter for the tokens
    filter: TokenFilterInput
    # Limit of tokens to return
    limit: Int = 40
    # offset from the start of tokens
    offset: Int = 0
  ): [RawToken!]! @aws_api_key @aws_cognito_user_pools
  # Gets the callers identity
  self: Self @aws_lambda @aws_api_key @aws_cognito_user_pools
  # Resolves the resolver and returns the expected tokens
  resolve(resolver: String!, modifiers: [ResolverModifierValueInput]): [Token]
    @aws_lambda
    @aws_cognito_user_pools
  #Returns all resolvers for a project
  resolvers(
    project: String!
    filter: ResolverFilterInput
    limit: Int = 40
    offset: Int = 0
  ): [Resolver] @aws_lambda @aws_cognito_user_pools
  #Returns a single resolver
  resolver(urn: String!): Resolver @aws_lambda @aws_cognito_user_pools

  apiKeys(organization: String!
    filter: ApiKeyFilterInput
    limit: Int = 40
    offset: Int = 0
  ): [APIKeyWithoutValue] @aws_api_key @aws_cognito_user_pools @aws_lambda
}


input ApiKeyFilterInput {
  urn: StringFilterInput
  name: StringFilterInput
}


type Mutation @aws_lambda @aws_cognito_user_pools {
  ### Creation
  #### Creates a new project for the organization
  createProject(organization: String!, input: ProjectInput!): Project
    @aws_lambda
    @aws_cognito_user_pools
  # Creates a new policy for the organization
  createPolicy(organization: String!, input: PolicyInput!): Policy
    @aws_lambda
    @aws_cognito_user_pools
  # Creates a new group that can have an associated policy to control it
  createGroup(organization: String!, input: GroupInput!): Group
    @aws_lambda
    @aws_cognito_user_pools
  # Creates a new organization
  createOrganization(input: OrganizationInput!): Organization
  # Creates a new API Keyt
  createAPIKey(organization: String!, input: APIKeyInput!): APIKey
  # Creates a new Token
  createToken(set: String!, input: TokenInput!): RawToken
    @aws_lambda
    @aws_cognito_user_pools
  # Bulk token creation. Limit of 50 tokens at a time
  bulkCreateToken(set: String!, input: [TokenInput]!): [RawToken]
    @aws_lambda
    @aws_cognito_user_pools
  # Creates a new token set
  createTokenSet(project: String!, input: TokenSetInput!): TokenSet
    @aws_lambda
    @aws_cognito_user_pools
  # Creates a new Resolver
  createResolver(project: String!, input: ResolverInput!): Resolver
    @aws_lambda
    @aws_cognito_user_pools
  # Creates a release by freezing a resolvers output
  createRelease(project: String!, input: ReleaseInput!): Release
    @aws_lambda
    @aws_cognito_user_pools


  # Creates a new generator definition 
    createGenerator(project: String!, input: GeneratorInput!): Generator
    @aws_lambda
    @aws_cognito_user_pools

  ### Membership
  #### Adds a member that already exists as part of your organization to a group
  addMemberToGroup(group: String!, entity: String!): String
  # Removes a member from a group in your organization
  removeMemberFromGroup(group: String!, user: String!): String
  # request that a member join your organization if they haven't already
  inviteToOrganization(organization: String!, user: String!): Invitation
  # Removes a member from an organization
  removeFromOrganization(organization: String!, user: String!): Boolean
  # Accepts an invitation to join an organization
  acceptInvitation(urn: String!): String
  # Declines an invitation to join an organization
  declineInvitation(urn: String!): String
  ### Updates
  #### Update the values of an existing token
  updateToken(urn: String!, input: TokenUpdateInput!): RawToken
    @aws_lambda
    @aws_cognito_user_pools
  updateTokenSet(urn: String!, input: TokenSetUpdateInput!): TokenSet
    @aws_lambda
    @aws_cognito_user_pools
  updateResolver(urn: String!, input: ResolverInput!): Resolver
    @aws_lambda
    @aws_cognito_user_pools
  updatePolicy(urn: String!, input: PolicyInputUpdate!): Policy
     @aws_lambda
    @aws_cognito_user_pools
  updateProject(urn: String!, input: ProjectUpdateInput!): Project
  @aws_lambda
  @aws_cognito_user_pools
  updateGroup(urn: String!, input: GroupUpdateInput!): Project
  @aws_lambda
  @aws_cognito_user_pools
  updateOrganization(urn: String!, input: OrganizationUpdateInput!): Organization
    @aws_lambda
    @aws_cognito_user_pools
  # Regenerates an API Key, removing its value from use
  regenerateApiKey(urn: String!): APIKey
  ### Deletion
  #### Deletes a token from a set
  deletePolicy(urn: String!): Policy @aws_lambda @aws_cognito_user_pools
  deleteAPIKey(urn: String!): APIKey
  deleteGroup(urn: String!): Group @aws_lambda @aws_cognito_user_pools
  deleteResolver(urn: String!): Resolver @aws_lambda @aws_cognito_user_pools
  deleteToken(urn: String!): RawToken @aws_lambda @aws_cognito_user_pools
  deleteTokenSet(urn: String!): TokenSet @aws_lambda @aws_cognito_user_pools
  deleteProject(urn: String!): Project @aws_lambda @aws_cognito_user_pools
  deleteOrganization(urn: String!): Project @aws_cognito_user_pools
  # Deletes an invitation from your organization to a user
  deleteInvitation(urn: String!): Invitation
  attachPolicyToGroup(group:String!, policy:String!): Group @aws_lambda @aws_cognito_user_pools
  detachPolicyFromGroup(group:String!, policy:String!): Group @aws_lambda @aws_cognito_user_pools
}

type Subscription @aws_lambda @aws_cognito_user_pools {
  ### Tokens
  ####  Subscribe to all new tokens created in a token set
  onCreateToken(setUrn: String!): RawToken
    @aws_subscribe(mutations: ["createToken"])
  #  Subscribe to token Changes
  onUpdateToken(setUrn: String!): RawToken
    @aws_subscribe(mutations: ["updateToken"])
  onDeleteToken(setUrn: String!): RawToken
    @aws_subscribe(mutations: ["deleteToken"])
  ### TokenSets
  ####  Subscribe to all new tokens sets created by an organization
  onCreateTokenSet(projectUrn: String!): TokenSet
    @aws_subscribe(mutations: ["createTokenSet"])
  #  Subscribe to all new tokens sets created by an organization
  onUpdateTokenSet(projectUrn: String!): TokenSet
    @aws_subscribe(mutations: ["updateTokenSet"])
  #Subscribe to tokenSet deletions
  onDeleteTokenSet(projectUrn: String!): TokenSet
    @aws_subscribe(mutations: ["deleteTokenSet"])
  #  Subscribe to all new groups created for the organization
  onCreateGroup(organization: String!): Group
    @aws_subscribe(mutations: ["createGroup"])
}


type APIKey {
  name: String
  description: String
  value: String
  urn: String
}

type APIKeyIdentity {
  name: String
  urn: String
}

input APIKeyInput {
  name: String!
  description: String
}

type APIKeyWithoutValue @aws_lambda @aws_cognito_user_pools {
  name: String
  lastUsed: AWSDateTime
  description: String
  urn: String
}

input AliasTokenSetInput {
  # The name of the alias
  alias: String!
  # The urn of the set we want to alias
  set: String!
}

input AliasTuple {
  name: String!
  value: String!
}

type ColorValue {
  raw: String
  hex: String
  hsla: [Int]
  rgba: [Int]
}

union Entity = User | APIKeyIdentity

type Group @aws_lambda @aws_cognito_user_pools {
  created: AWSDateTime! @aws_lambda @aws_cognito_user_pools
  name: String! @aws_lambda @aws_cognito_user_pools
  urn: String @aws_lambda @aws_cognito_user_pools
  description: String @aws_lambda @aws_cognito_user_pools
  members: [Entity] @aws_lambda @aws_cognito_user_pools
  policy: Policy @aws_lambda @aws_cognito_user_pools
}

input GroupFilterInput {
  urn: GroupUrnFilterInput
  name: GroupStringFilterInput
}

input TokenSetsFilterInput{
  name:StringFilterInput
}


input GroupUpdateInput {
  name: String
  description: String
  icon: String
}


input GroupInput {
  name: String!
  description: String
  icon: String
}

input GroupStringFilterInput {
  # Equal to
  eq: String
}

input GroupUrnFilterInput {
  # Equal to
  eq: String
}

type Identity @aws_api_key @aws_lambda @aws_cognito_user_pools {
  # The urn of the underlying identity you are operation as .
  urn: String
  # Whether your identity is authenticated or not
  authenticated: Boolean!
}

input IntFilterInput {
  # Equal to
  eq: Int
  # Not equal to
  ne: Int
  # Less than
  lt: Int
  # Greater than
  gt: Int
  # less than or equal to
  le: Int
  # greater than or equal to
  ge: Int
}

type Invitation @aws_lambda @aws_cognito_user_pools {
  # Organization urn
  organization: String!
  # User urn
  user: String!
  status: InvitationStatus
}

enum InvitationStatus {
  PENDING
  DECLINED
  ACCEPTED
}

type Metadata {
  # Time of creation of the resource
  created: AWSDateTime
  #  The entity who initially created this token
  createdBy: Entity
  #  The last entity to update the token directly.
  lastUpdatedBy: Entity
}



type Organization @aws_api_key @aws_lambda @aws_cognito_user_pools {
  # Unique id of the organization
  urn: String
  # Date that the org was created
  created: AWSDateTime
  # The user that created the organization
  owner: User

  # Name is not unique
  name: String
  # Optional description
  description: String
  # Visibility of the org to the public
  visibility: Visibility
  # The account id
  account: String
  # The stripe account id. Might be null if user is on free tier
  payment: String
  # Whether or not SSO is enabled
  ssoEnabled: Boolean
  # Optional icon
  icon: String
  # The tier associated with the organization
  tier: OrganizationTier
  # Projects inside the organization
  projects(
    filter: ProjectFilterInput
    limit: Int = 40
    offset: Int = 0
  ): [Project]


  # Groups inside the organization
  groups(filter: GroupFilterInput, limit: Int = 40, offset: Int = 0): [Group]
  # Policies inside the organization
  policies(
    filter: PolicyFilterInput
    limit: Int = 40
    offset: Int = 0
  ): [Policy]
  # The api keys owned by the organization
  apiKeys: [APIKeyWithoutValue]
  # User of the organization
  users(filter: UserFilterInput, limit: Int = 40, offset: Int = 0): [User]
}




input OrganizationFilterInput {
  urn: StringFilterInput
  name: StringFilterInput
  owner: StringFilterInput
  visibility: VisibilityInput
}

input OrganizationUpdateInput {
  name: String
  description: String
  visibility: Visibility
  icon: String
  tier: OrganizationTier
}


input OrganizationInput {
  name: String!
  description: String
  visibility: Visibility!
  icon: String
  tier: OrganizationTier!
}

type OrganizationMemberShip {
  created: AWSDateTime!
}

enum OrganizationTier {
  FREE
  STARTER
  STUDIO
  ENTERPRISE
}

type Policy @aws_lambda @aws_cognito_user_pools {
  created: AWSDateTime
  name: String!
  urn: String
  description: String
  value: PolicyDoc!
}

type PolicyDoc {
  version: String!
  statement: [PolicyStatement]!
}

input PolicyDocInput {
  version: String!
  statement: [PolicyStatementInput!]!
}

input PolicyFilterInput {
  name: PolicyStringFilterInput
  urn: String
}


input PolicyInputUpdate {
  name: String
  description: String
  value: PolicyDocInput
}


input PolicyInput {
  name: String!
  description: String
  value: PolicyDocInput!
}

type PolicyStatement {
  effect: String!
  action: [String]!
  resource: [String]!
}

input PolicyStatementInput {
  effect: String!
  action: [String]!
  resource: [String]!
}

input PolicyStringFilterInput {
  eq: String
}

type Project @aws_lambda @aws_cognito_user_pools {
  created: AWSDateTime!
  name: String!
  urn: String!
  orgUrn: String
  visibility: Visibility
  icon: String
  description: String
  sets(
    filter: TokenSetFilterInput
    limit: Int = 40
    offset: Int = 0
  ): [TokenSet]
  resolvers(
    filter: ResolverFilterInput
    limit: Int = 40
    offset: Int = 0
  ): [Resolver]
}

input ProjectFilterInput {
  urn: StringFilterInput
  name: StringFilterInput
  visibility: VisibilityInput
}


input ProjectUpdateInput {
  # Unique name of the project
  name: String
  # Optional description of the project
  description: String
  # Visibility of the project
  visibility: Visibility
  # Icon associated with your project
  icon: String
}

input ProjectInput {
  # Unique name of the project
  name: String!
  # Optional description of the project
  description: String
  # Visibility of the project
  visibility: Visibility!
  # Icon associated with your project
  icon: String
}


# Raw tokens are the tokens that are formatted after being input into the system. They do not reflect the final token values from resolved tokens
union RawToken = Raw_Token_color | Raw_Token_scalar | Raw_Token_typography

type Raw_Token_color implements TokenInterface
  @aws_lambda
  @aws_cognito_user_pools {
  description: String
  name: String
  value: String
  urn: String
  setUrn: String
  # JSON stringified extensions data
  extensions: AWSJSON
  metadata: Metadata
  type: TokenType
}

# Scalar raw tokens are those with a simple value output such as a string. The following are all scalar
#### assets - Assumes a string output with a URL
#### opacity - Assumes a simple numeric output
type Raw_Token_scalar implements TokenInterface
  @aws_lambda
  @aws_cognito_user_pools {
  description: String
  name: String
  value: String
  urn: String
  extensions: AWSJSON
  setUrn: String
  metadata: Metadata
  type: TokenType
}

# Scalar raw tokens are those with a simple value output such as a string. The following are all scalar
#### assets - Assumes a string output with a URL
#### opacity - Assumes a simple numeric output
type Raw_Token_typography implements TokenInterface
  @aws_lambda
  @aws_cognito_user_pools {
  description: String
  name: String
  value:String
  typography: Typography
  urn: String
  extensions: AWSJSON
  setUrn: String
  metadata: Metadata
  type: TokenType
}


interface ResolvedTokenInterface {
  description: String
  name: String
  type: TokenType
  metadata: Metadata
}

type Resolver @aws_lambda @aws_cognito_user_pools {
  name: String
  description: String
  urn: String
  sources: [ResolverSource]
  modifiers: [ResolverModifierOutput]
  release(
    filter: ReleaseFilterInput
    limit: Int = 40
    offset: Int = 0
  ): [Release]
}

input ResolverFilterInput {
  urn: StringFilterInput
  name: StringFilterInput
}

input ResolverInput {
  # Optional description of the resolver
  description: String
  # Name of the resolver
  name: String!
  #Src tokens sets. These override the default source sets
  src: [ResolverSourceInput]!
  # Multiple potential aliases to resolve
  modifiers: [ResolverModifier]
}

input ResolverModifier {
  # Name of the modifier
  name: String!
  # Optional string that will rename the set during resolution
  alias: String
  # Default values for the modifier
  default: String
  # Type of the modifier
  type: ResolverModifierType
  # If using ENUMERATED type, then this is an array on length N>=1 otherwise N=1
  values: [ResolverModifierValueInput]
}

type ResolverModifierOutput {
  # Name of the modifier
  name: String!
  # Optional string that will rename the set during resolution
  alias: String
  # Default values for the modifier
  default: String
  # Type of the modifier
  type: ResolverModifierType
  # If using ENUMERATED type, then this is an array on length N>=1 otherwise N=1
  values: [ResolverModifierValue]
}

enum ResolverModifierType {
  ENUMERATED
  DYNAMIC
  FIXED
}

type ResolverModifierValue {
  name: String
  # urn of the token sret
  urn: String
  ## TODO . These are not currently implemented but will support versioning and branches in the future
  version: String
  branch: String
}

input ResolverModifierValueInput {
  # Name of the modifier you are targetting
  name: String!
  # alias a value if using enumerated values
  alias: String
  # specify exact values
  urn: String
  version: String
  branch: String
}

type ResolverSource {
  # The urn of the token set
  urn: String!
  node: TokenSet
  ## TODO . These are not currently implemented but will support versioning and branches in the future
  version: String
  branch: String
}

input ResolverSourceInput {
  # The urn of the token sert
  urn: String!
  ## TODO . These are not currently implemented but will support versioning and branches in the future
  version: String
  branch: String
}

type Self {
  identity: Identity @aws_api_key @aws_lambda @aws_cognito_user_pools
  # Any invitation of the user when logged in with user auth
  invitations: [Invitation]
  # information about the user if logged in with user auth
  user: User
  # Organizations that the user owns
  organizations: [Organization]
  # Retrieves the applicable permissions for yourself in the context of an organization
  permissions(orgUrn: String):[PolicyDoc]
}

input StringFilterInput {
  eq: String
  ne: String
  beginsWith: String
}


union Token = Token_color | Token_scalar | Token_Typography

input TokenFilterInput {
  urn: StringFilterInput
  name: StringFilterInput
  type: TokenTypeFilterInput
}

input TokenInput {
  description: String
  name: String!
  type: TokenType!
  extensions: AWSJSON
  value: String!
}

interface TokenInterface {
  description: String
  urn: String
  metadata: Metadata
  name: String
  setUrn: String
  type: TokenType
}

type TokenSet @aws_lambda @aws_cognito_user_pools {
  urn: String
  metadata: Metadata
  name: String
  projectUrn: String
  tokens(
    filter: TokenFilterInput # Limit of tokens to return
    limit: Int = 40 # offset from the start of tokens
    offset: Int = 0
  ): [RawToken!]!
}

input TokenSetFilterInput {
  urn: StringFilterInput
  name: StringFilterInput
}

input TokenSetInput {
  name: String!
  description: String
}

input TokenSetUpdateInput {
  name: String
  description: String
}

enum TokenType {
  any
  assets
  border
  borderRadius
  borderWidth
  boxShadow
  color
  composition
  dimension
  fontFamilies
  fontSizes
  fontWeights
  letterSpacing
  lineHeights
  opacity
  other
  paragraphSpacing
  sizing
  spacing
  textCase
  textDecoration
  typography
}

input TokenTypeFilterInput {
  eq: TokenType
  ne: TokenType
}

input TokenUpdateInput {
  description: String
  name: String
  value: String
}

type Token_Composition implements ResolvedTokenInterface {
  description: String
  name: String
  value: String
  type: TokenType
  metadata: Metadata
}

type Token_Typography implements ResolvedTokenInterface
  @aws_lambda
  @aws_cognito_user_pools {
  description: String
  name: String
  value: String
  metadata: Metadata
  type: TokenType
}

type Token_color implements ResolvedTokenInterface
  @aws_lambda
  @aws_cognito_user_pools {
  description: String
  name: String
  value: String
  type: TokenType
  metadata: Metadata
}

type Token_scalar implements ResolvedTokenInterface
  @aws_lambda
  @aws_cognito_user_pools {
  description: String
  name: String
  value: String
  type: TokenType
  metadata: Metadata
}

type Typography {
  fontFamily: String
  fontWeight: String
  letterSpacing: String
  lineHeight: String
  fontSize: String
  paragraphIndent: String
  paragraphSpacing: String
  textCase: String
  textDecoration: String
}

type User {
  # Display name of the user
  name: String
  # A preferred name of the user
  givenName:String
  # Urn of the user
  urn: String
  # Optional User description
  description: String
  # The icon of the user as html link to an image
  icon: String
  # Visibility of the user to search
  visibility: Visibility
}

input UserFilterInput {
  name: StringFilterInput
}

enum Visibility {
  PUBLIC
  PRIVATE
}

input VisibilityInput {
  eq: Visibility
}

schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}
