schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

interface ResolvedTokenInterface {
  description: String
  metadata: Metadata
  name: String
  type: TokenType
}

interface TokenInterface {
  description: String
  metadata: Metadata
  name: String
  setUrn: String
  type: TokenType
  urn: String
}

union Entity = APIKeyIdentity | User

#  Raw tokens are the tokens that are formatted after being input into the system. They do not reflect the final token values from resolved tokens
union RawToken = Raw_Token_color | Raw_Token_scalar | Raw_Token_typography

union Token = Token_Typography | Token_color | Token_scalar

type APIKey {
  description: String
  name: String
  urn: String
  value: String
}

type APIKeyIdentity {
  name: String
  urn: String
}

type APIKeyWithoutValue @aws_cognito_user_pools @aws_lambda {
  description: String
  name: String
  urn: String
}

type ColorValue {
  hex: String
  hsla: [Int]
  raw: String
  rgba: [Int]
}

type Group @aws_cognito_user_pools @aws_lambda {
  created: AWSDateTime! @aws_cognito_user_pools @aws_lambda
  description: String @aws_cognito_user_pools @aws_lambda
  members: [Entity] @aws_cognito_user_pools @aws_lambda
  name: String! @aws_cognito_user_pools @aws_lambda
  policy: Policy @aws_cognito_user_pools @aws_lambda
  urn: String @aws_cognito_user_pools @aws_lambda
}

type Identity @aws_api_key @aws_cognito_user_pools @aws_lambda {
  #  Whether your identity is authenticated or not
  authenticated: Boolean!
  #  The urn of the underlying identity you are operation as .
  urn: String
}

type Invitation @aws_cognito_user_pools @aws_lambda {
  #  Organization urn
  organization: String!
  status: InvitationStatus
  #  User urn
  user: String!
}

type Metadata {
  #  Time of creation of the resource
  created: AWSDateTime
  #   The entity who initially created this token
  createdBy: Entity
  #   The last entity to update the token directly.
  lastUpdatedBy: Entity
}

type Mutation @aws_cognito_user_pools @aws_lambda {
  #  Accepts an invitation to join an organization
  acceptInvitation(urn: String!): String
  # ## Membership
  #### Adds a member that already exists as part of your organization to a group
  addMemberToGroup(entity: String!, group: String!): String
  #  Bulk token creation. Limit of 50 tokens at a time
  bulkCreateToken(input: [TokenInput]!, set: String!): [RawToken] @aws_cognito_user_pools @aws_lambda
  #  Creates a new API Key
  createAPIKey(input: APIKeyInput!, organization: String!): APIKey
  #  Creates a new group that can have an associated policy to control it
  createGroup(input: GroupInput!, organization: String!): Group @aws_cognito_user_pools @aws_lambda
  #  Creates a new organization
  createOrganization(input: OrganizationInput!): Organization
  #  Creates a new policy for the organization
  createPolicy(input: PolicyInput!, organization: String!): Policy @aws_cognito_user_pools @aws_lambda
  # ## Creation
  #### Creates a new project for the organization
  createProject(input: ProjectInput!, organization: String!): Project @aws_cognito_user_pools @aws_lambda
  #  Creates a release by freezing a resolvers output
  createRelease(input: ReleaseInput!, resolver: String!): Release @aws_cognito_user_pools @aws_lambda
  #  Creates a new Resolver
  createResolver(input: ResolverInput!, project: String!): Resolver @aws_cognito_user_pools @aws_lambda
  #  Creates a new Token
  createToken(input: TokenInput!, set: String!): RawToken @aws_cognito_user_pools @aws_lambda
  #  Creates a new token set
  createTokenSet(input: TokenSetInput!, project: String!): TokenSet @aws_cognito_user_pools @aws_lambda
  #  Declines an invitation to join an organization
  declineInvitation(urn: String!): String
  deleteAPIKey(urn: String!): APIKey
  deleteGroup(urn: String!): Group @aws_cognito_user_pools @aws_lambda
  #  Deletes an invitation from your organization to a user
  deleteInvitation(urn: String!): Invitation
  # ## Deletion
  #### Deletes a token from a set
  deletePolicy(urn: String!): Policy @aws_cognito_user_pools @aws_lambda
  deleteProject(urn: String!): Project @aws_cognito_user_pools @aws_lambda
  deleteResolver(urn: String!): Resolver @aws_cognito_user_pools @aws_lambda
  deleteToken(urn: String!): RawToken @aws_cognito_user_pools @aws_lambda
  deleteTokenSet(urn: String!): TokenSet @aws_cognito_user_pools @aws_lambda
  #  request that a member join your organization if they haven't already
  inviteToOrganization(organization: String!, user: String!): Invitation
  #  Regenerates an API Key, removing its value from use
  regenerateApiKey(urn: String!): APIKey
  #  Removes a member from an organization
  removeFromOrganization(organization: String!, user: String!): Boolean
  #  Removes a member from a group in your organization
  removeMemberFromGroup(group: String!, user: String!): String
  updatePolicy(input: PolicyInput!, urn: String!): Policy
  updateProject(input: ProjectInput!, urn: String!): Project @aws_cognito_user_pools @aws_lambda
  updateResolver(input: ResolverInput!, urn: String!): Resolver @aws_cognito_user_pools @aws_lambda
  # ## Updates
  #### Update the values of an existing token
  updateToken(input: TokenUpdateInput!, urn: String!): RawToken @aws_cognito_user_pools @aws_lambda
  updateTokenSet(input: TokenSetUpdateInput!, urn: String!): TokenSet @aws_cognito_user_pools @aws_lambda
}

type Organization @aws_api_key @aws_cognito_user_pools @aws_lambda {
  #  The account id
  account: String
  #  The api keys owned by the organization
  apiKeys: [APIKeyWithoutValue]
  #  Date that the org was created
  created: AWSDateTime
  #  Optional description
  description: String
  #  Groups inside the organization
  groups(filter: GroupFilterInput, limit: Int, offset: Int): [Group]
  #  Optional icon
  icon: String
  #  Name is not unique
  name: String
  #  The stripe account id. Might be null if user is on free tier
  payment: String
  #  Policies inside the organization
  policies(filter: PolicyFilterInput, limit: Int, offset: Int): [Policy]
  #  Projects inside the organization
  projects(filter: ProjectFilterInput, limit: Int, offset: Int): [Project]
  #  Whether or not SSO is enabled
  ssoEnabled: Boolean
  #  The tier associated with the organization
  tier: OrganizationTier
  #  Unique id of the organization
  urn: String
  #  User of the organization
  users(filter: UserFilterInput, limit: Int, offset: Int): [User]
  #  Visibility of the org to the public
  visibility: Visibility
}

type OrganizationMemberShip {
  created: AWSDateTime!
}

type Policy @aws_cognito_user_pools @aws_lambda {
  created: AWSDateTime
  description: String
  name: String!
  urn: String
  value: PolicyDoc!
}

type PolicyDoc {
  statement: PolicyStatement!
  version: String!
}

type PolicyStatement {
  action: [String]!
  effect: String!
  resource: [String]!
}

type Project @aws_cognito_user_pools @aws_lambda {
  created: AWSDateTime!
  description: String
  icon: String
  name: String!
  orgUrn: String
  resolvers(filter: ResolverFilterInput, limit: Int, offset: Int): [Resolver]
  sets(filter: TokenSetFilterInput, limit: Int, offset: Int): [TokenSet]
  urn: String!
  visibility: Visibility
}

type Query @aws_cognito_user_pools @aws_lambda {
  #  Retrieves all projects for an organization
  groups(filter: GroupFilterInput, limit: Int, offset: Int, organization: String!): [Group] @aws_cognito_user_pools @aws_lambda
  #  Retrieves information about the organizations
  organizations(filter: OrganizationFilterInput, limit: Int, offset: Int): [Organization] @aws_api_key @aws_cognito_user_pools @aws_lambda
  #  queries policies available to the org. The organization is the organization urn
  policies(limit: Int, offset: Int, organization: String!): [Policy] @aws_cognito_user_pools @aws_lambda
  #  Retrieves all projects for an organization. When using the public api key mode you cannot ask for non public resources
  projects(filter: ProjectFilterInput, limit: Int, offset: Int, organization: String!): [Project] @aws_api_key @aws_cognito_user_pools @aws_lambda
  #  Resolves the resolver and returns the expected tokens
  resolve(modifiers: [ResolverModifierValueInput], resolver: String!): [Token] @aws_cognito_user_pools @aws_lambda
  # Returns a single resolver
  resolver(urn: String!): Resolver @aws_cognito_user_pools @aws_lambda
  # Returns all resolvers for a project
  resolvers(filter: ResolverFilterInput, limit: Int, offset: Int, project: String!): [Resolver] @aws_cognito_user_pools @aws_lambda
  #  Gets the callers identity
  self: Self @aws_api_key @aws_cognito_user_pools @aws_lambda
  #  Retrieves a specific token
  token(urn: String!): RawToken @aws_api_key @aws_cognito_user_pools
  #   Retrieves a specific tokenset
  tokenSet(urn: String!): TokenSet @aws_cognito_user_pools @aws_lambda
  #   Retrieves all accessible tokensets for the current project
  tokenSets(limit: Int, offset: Int, project: String!): [TokenSet!]! @aws_cognito_user_pools @aws_lambda
  #  Retrieves all tokens of the current set
  tokens(filter: TokenFilterInput, limit: Int, offset: Int, set: String!): [RawToken!]! @aws_api_key @aws_cognito_user_pools
  #  Retrieves all invitations in the context of your user
  userInvitations(limit: Int): [Invitation] @aws_cognito_user_pools @aws_lambda
}

type Raw_Token_color implements TokenInterface @aws_cognito_user_pools @aws_lambda {
  description: String
  #  JSON stringified extensions data
  extensions: AWSJSON
  metadata: Metadata
  name: String
  setUrn: String
  type: TokenType
  urn: String
  value: String
}

#  Scalar raw tokens are those with a simple value output such as a string. The following are all scalar
#### assets - Assumes a string output with a URL
#### opacity - Assumes a simple numeric output
type Raw_Token_scalar implements TokenInterface @aws_cognito_user_pools @aws_lambda {
  description: String
  extensions: AWSJSON
  metadata: Metadata
  name: String
  setUrn: String
  type: TokenType
  urn: String
  value: String
}

#  Scalar raw tokens are those with a simple value output such as a string. The following are all scalar
#### assets - Assumes a string output with a URL
#### opacity - Assumes a simple numeric output
type Raw_Token_typography implements TokenInterface @aws_cognito_user_pools @aws_lambda {
  description: String
  extensions: AWSJSON
  metadata: Metadata
  name: String
  setUrn: String
  type: TokenType
  urn: String
  value: Typography
}

type Release {
  #  Date that the release was created
  created: AWSDateTime
  #  The entity who created the release
  releasedBy: Entity
  #  tokens included in the release
  tokens: [Token]
  #  unique urn of the release
  urn: String
  #  The semver version string
  version: String
}

type Resolver @aws_cognito_user_pools @aws_lambda {
  description: String
  modifiers: [ResolverModifierOutput]
  name: String
  release(filter: ReleaseFilterInput, limit: Int, offset: Int): [Release]
  sources: [ResolverSource]
  urn: String
}

type ResolverModifierOutput {
  #  Optional string that will rename the set during resolution
  alias: String
  #  Default values for the modifier
  default: String
  #  Name of the modifier
  name: String!
  #  Type of the modifier
  type: ResolverModifierType
  #  If using ENUMERATED type, then this is an array on length N>=1 otherwise N=1
  values: [ResolverModifierValue]
}

type ResolverModifierValue {
  branch: String
  name: String
  #  urn of the token sret
  urn: String
  # # TODO . These are not currently implemented but will support versioning and branches in the future
  version: String
}

type ResolverSource {
  branch: String
  #  The urn of the token sert
  urn: String!
  # # TODO . These are not currently implemented but will support versioning and branches in the future
  version: String
}

type Self {
  identity: Identity @aws_api_key @aws_cognito_user_pools @aws_lambda
  #  Any invitation of the user when logged in with user auth
  invitations: [Invitation]
  #  Organizations that the user owns
  organizations: [Organization]
  #  information about the user if logged in with user auth
  user: User
}

type Subscription @aws_cognito_user_pools @aws_lambda {
  onDeleteToken(setUrn: String!): RawToken @aws_subscribe(mutations : ["deleteToken"])
  # Subscribe to tokenSet deletions
  onDeleteTokenSet(projectUrn: String!): TokenSet @aws_subscribe(mutations : ["deleteTokenSet"])
  #   Subscribe to all new groups created for the organization
  onNewGroup(organization: String!): Group @aws_subscribe(mutations : ["createGroup"])
  # ## Tokens
  ####  Subscribe to all new tokens created in a token set
  onNewToken(setUrn: String!): RawToken @aws_subscribe(mutations : ["createToken"])
  # ## TokenSets
  ####  Subscribe to all new tokens sets created by an organization
  onNewTokenSet(projectUrn: String!): TokenSet @aws_subscribe(mutations : ["createTokenSet"])
  #   Subscribe to token Changes
  onUpdateToken(setUrn: String!): RawToken @aws_subscribe(mutations : ["updateToken"])
  #   Subscribe to all new tokens sets created by an organization
  onUpdateTokenSet(projectUrn: String!): TokenSet @aws_subscribe(mutations : ["updateTokenSet"])
}

type TokenSet @aws_cognito_user_pools @aws_lambda {
  metadata: Metadata
  name: String
  projectUrn: String
  tokens(filter: TokenFilterInput, limit: Int, offset: Int): [RawToken!]!
  urn: String
}

type Token_Composition implements ResolvedTokenInterface {
  description: String
  metadata: Metadata
  name: String
  type: TokenType
  value: String
}

type Token_Typography implements ResolvedTokenInterface @aws_cognito_user_pools @aws_lambda {
  description: String
  metadata: Metadata
  name: String
  type: TokenType
  value: Typography
}

type Token_color implements ResolvedTokenInterface @aws_cognito_user_pools @aws_lambda {
  description: String
  metadata: Metadata
  name: String
  type: TokenType
  value: String
}

type Token_scalar implements ResolvedTokenInterface @aws_cognito_user_pools @aws_lambda {
  description: String
  metadata: Metadata
  name: String
  type: TokenType
  value: String
}

type Typography {
  fontFamily: String
  fontSize: String
  fontWeight: String
  letterSpacing: String
  lineHeight: String
  paragraphIndent: String
  paragraphSpacing: String
  textCase: String
  textDecoration: String
}

type User {
  #  Optional User description
  description: String
  #  The icon of the user as html link to an image
  icon: String
  #  Display name of the user
  name: String
  #  Urn of the user
  urn: String
  #  Visibility of the user to search
  visibility: Visibility
}

enum InvitationStatus {
  ACCEPTED
  DECLINED
  PENDING
}

enum OrganizationTier {
  ENTERPRISE
  FREE
  STARTER
  STUDIO
}

enum ResolverModifierType {
  DYNAMIC
  ENUMERATED
  FIXED
}

enum TokenType {
  any
  assets
  border
  borderRadius
  borderWidth
  boxShadow
  color
  composition
  dimension
  fontFamilies
  fontSizes
  fontWeights
  letterSpacing
  lineHeights
  opacity
  other
  paragraphSpacing
  sizing
  spacing
  textCase
  textDecoration
  typography
}

enum Visibility {
  PRIVATE
  PUBLIC
}

input APIKeyInput {
  description: String
  name: String!
}

input AliasTokenSetInput {
  #  The name of the alias
  alias: String!
  #  The urn of the set we want to alias
  set: String!
}

input AliasTuple {
  name: String!
  value: String!
}

input GroupFilterInput {
  name: GroupStringFilterInput
  urn: GroupUrnFilterInput
}

input GroupInput {
  description: String
  icon: String
  name: String!
}

input GroupStringFilterInput {
  #  Equal to
  eq: String
}

input GroupUrnFilterInput {
  #  Equal to
  eq: String
}

input IntFilterInput {
  #  Equal to
  eq: Int
  #  greater than or equal to
  ge: Int
  #  Greater than
  gt: Int
  #  less than or equal to
  le: Int
  #  Less than
  lt: Int
  #  Not equal to
  ne: Int
}

input OrganizationFilterInput {
  name: StringFilterInput
  urn: StringFilterInput
  visibility: VisibilityInput
}

input OrganizationInput {
  description: String
  icon: String
  name: String!
  tier: OrganizationTier!
  visibility: Visibility!
}

input PolicyDocInput {
  statement: [PolicyStatementInput!]!
  version: String!
}

input PolicyFilterInput {
  name: PolicyStringFilterInput
  urn: String
}

input PolicyInput {
  description: String
  name: String!
  value: PolicyDocInput!
}

input PolicyStatementInput {
  action: [String]!
  effect: String!
  resource: [String]!
}

input PolicyStringFilterInput {
  eq: String
}

input ProjectFilterInput {
  name: StringFilterInput
  urn: StringFilterInput
  visibility: VisibilityInput
}

input ProjectInput {
  #  Optional description of the project
  description: String
  #  Icon associated with your project
  icon: String
  #  Unique name of the project
  name: String!
  #  Visibility of the project
  visibility: Visibility!
}

input ReleaseFilterInput {
  name: StringFilterInput
  urn: StringFilterInput
  version: StringFilterInput
}

input ReleaseInput {
  name: String
  version: String!
}

input ResolverFilterInput {
  name: StringFilterInput
  urn: StringFilterInput
}

input ResolverInput {
  #  Optional description of the resolver
  description: String
  #  Multiple potential aliases to resolve
  modifiers: [ResolverModifier]
  #  Name of the resolver
  name: String!
  # Src tokens sets. These override the default source sets
  src: [ResolverSourceInput]!
}

input ResolverModifier {
  #  Optional string that will rename the set during resolution
  alias: String
  #  Default values for the modifier
  default: String
  #  Name of the modifier
  name: String!
  #  Type of the modifier
  type: ResolverModifierType
  #  If using ENUMERATED type, then this is an array on length N>=1 otherwise N=1
  values: [ResolverModifierValueInput]
}

input ResolverModifierValueInput {
  #  alias a value if using enumerated values
  alias: String
  branch: String
  #  Name of the modifier you are targetting
  name: String!
  #  specify exact values
  urn: String
  version: String
}

input ResolverSourceInput {
  branch: String
  #  The urn of the token sert
  urn: String!
  # # TODO . These are not currently implemented but will support versioning and branches in the future
  version: String
}

input StringFilterInput {
  beginsWith: String
  eq: String
  ne: String
}

input TokenFilterInput {
  name: StringFilterInput
  type: TokenTypeFilterInput
  urn: StringFilterInput
}

input TokenInput {
  description: String
  extensions: AWSJSON
  name: String!
  type: TokenType!
  value: String!
}

input TokenSetFilterInput {
  name: StringFilterInput
  urn: StringFilterInput
}

input TokenSetInput {
  description: String
  name: String!
}

input TokenSetUpdateInput {
  description: String
  name: String
}

input TokenTypeFilterInput {
  eq: TokenType
  ne: TokenType
}

input TokenUpdateInput {
  description: String
  name: String
  value: String
}

input UserFilterInput {
  name: StringFilterInput
}

input VisibilityInput {
  eq: Visibility
}
